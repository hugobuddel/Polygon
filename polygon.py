"""Polygon math.

Polygon makes allows polygons to be constructed from edges and to compute
intersections and unions of polygons.

It is primarily used for combining masks of images, for example for KiDS it
is used to combine manual masks and autogenerated masks in order to mask
bad regions of KiDS coadds.

Polygons are created from lists of edges. Polygons are converted such that they
- are not disjoint, that is, if a list of edges describes two disjoint
  Polygons, then a very thin connection is made between the two,
- do not have holes, that is, if a list of edges describe a Polygon with a
  hole, then a very small cut is made from the hole to the edge,
- all have the same orientation, and
- do not self intersect, e.g. a butterfly quadrilateral is split into two
  Polygons and joined.
"""

import itertools
import math

import random

random.seed(12)

DEBUG = 1
Message = lambda m, d: print(m)


def lazyproperty(fn):
    """Lazy property.

    http://stackoverflow.com/questions/3012421/python-lazy-property-decorator
    """
    attr_name = "_lazy_" + fn.__name__

    @property
    def _lazyproperty(self):
        if not hasattr(self, attr_name) or getattr(self, attr_name) is None:
            setattr(self, attr_name, fn(self))
        return getattr(self, attr_name)

    return _lazyproperty


class PolygonError(Exception):
    """"""

    pass


class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __hash__(self):
        return hash((self.x, self.y))

    def inside(self, polygon):
        """
        # http://www.ariel.com.au/a/python-point-int-poly.html

        # determine if a point is inside a given polygon or not
        # Polygon is a list of (x,y) pairs.
        """
        n = len(polygon.vertices)
        inside = False

        p1 = polygon.vertices[0]
        p1x, p1y = p1.x, p1.y
        for i in range(n + 1):
            p2 = polygon.vertices[i % n]
            p2x, p2y = p2.x, p2.y
            if self.y > min(p1y, p2y) and self.y <= max(p1y, p2y) and self.x <= max(p1x, p2x):
                xinters = (self.y - p1y) * (p2x - p1x) / (p2y - p1y) + p1x if p1y != p2y else 0
                if p1x == p2x or self.x <= xinters:
                    inside = not inside
            p1x, p1y = p2x, p2y

        return inside

    def __eq__(self, other):
        return self.x == other.x and self.y == other.y

    def __str__(self):
        return str((self.x, self.y))


class Segment:
    def __init__(self, start, end):
        self.start = start
        self.end = end

    def __hash__(self):
        return hash((self.start, self.end))

    def intersects(self, other):
        """Check if two segments intersect.

        http://stackoverflow.com/questions/3838329/how-can-i-check-if-two-segments-intersect
        """

        def ccw(a, b, c):
            """Are points a, b, c in counterclockwise order?

            https://bryceboe.com/2006/10/23/line-segment-intersection-algorithm/
            """
            return (c.y - a.y) * (b.x - a.x) > (b.y - a.y) * (c.x - a.x)

        # Return true if line segments AB and CD intersect
        # return ccw(a,c,D) != ccw(b,c,D) and ccw(a,b,c) != ccw(a,b,D)
        ccw1 = ccw(self.start, other.start, other.end)
        ccw2 = ccw(self.end, other.start, other.end)
        ccw3 = ccw(self.start, self.end, other.start)
        ccw4 = ccw(self.start, self.end, other.end)
        intersects = ccw1 != ccw2 and ccw3 != ccw4
        if intersects:
            p = self.intersection(other)
            # Parallel lines might require this check.
            if (
                ((self.start.x <= p.x <= self.end.x) | (self.start.x >= p.x >= self.end.x))
                & ((self.start.y <= p.y <= self.end.y) | (self.start.y >= p.y >= self.end.y))
                & ((other.start.x <= p.x <= other.end.x) | (other.start.x >= p.x >= other.end.x))
                & ((other.start.y <= p.y <= other.end.y) | (other.start.y >= p.y >= other.end.y))
            ):
                return True

        return False

    def intersection(self, other):
        """Get intersection of two segments.

        http://stackoverflow.com/questions/4543506/algorithm-for-intersection-of-2-lines
        """
        # def get_intersection(x1, y1, x2, y2, x3, y3, x4, y4):
        x1 = self.start.x
        y1 = self.start.y
        x2 = self.end.x
        y2 = self.end.y
        x3 = other.start.x
        y3 = other.start.y
        x4 = other.end.x
        y4 = other.end.y

        A1 = y2 - y1
        B1 = x1 - x2
        C1 = A1 * x1 + B1 * y1

        A2 = y4 - y3
        B2 = x3 - x4
        C2 = A2 * x3 + B2 * y3

        delta = A1 * B2 - A2 * B1
        if delta == 0:
            print("Lines are parallel")

        x = (B2 * C1 - B1 * C2) / delta
        y = (A1 * C2 - A2 * C1) / delta
        return Point(x, y)

    def length(self):
        return math.sqrt((self.end.x - self.start.x) ** 2 + (self.end.y - self.start.y) ** 2)

    def xs(self):
        return [self.start.x, self.end.x]

    def ys(self):
        return [self.start.y, self.end.y]

    def extend_end(self, factor=1.0):
        end_new = Point(
            x=self.start.x + (self.end.x - self.start.x) * factor,
            y=self.start.y + (self.end.y - self.start.y) * factor,
        )
        return Segment(start=self.start, end=end_new)

    def extend_start(self, factor=1.0):
        start_new = Point(
            x=self.end.x - (self.end.x - self.start.x) * factor, y=self.end.y - (self.end.y - self.start.y) * factor,
        )
        return Segment(start=start_new, end=self.end)

    def __eq__(self, other):
        return self.start == other.start and self.end == other.end

    def __str__(self):
        return str(((self.start.x, self.start.y), (self.end.x, self.end.y)))


class Polygon:
    _lazy_vertices = None

    @lazyproperty
    def vertices(self):
        return [edge.start for edge in self._lazy_edges]

    _lazy_edges = None

    @lazyproperty
    def edges(self):
        return [
            Segment(start, end)
            for (start, end) in zip(self._lazy_vertices, self._lazy_vertices[1:] + self._lazy_vertices[:1])
        ]

    def xs(self):
        return [p.x for p in self.vertices]

    def ys(self):
        return [p.y for p in self.vertices]

    @lazyproperty
    def xmean(self):
        return sum(self.xs()) / len(self)

    @lazyproperty
    def ymean(self):
        return sum(self.ys()) / len(self)

    @lazyproperty
    def xmin(self):
        return min(self.xs())

    @lazyproperty
    def xmax(self):
        return max(self.xs())

    @lazyproperty
    def ymin(self):
        return min(self.ys())

    @lazyproperty
    def ymax(self):
        return max(self.ys())

    def volume_bounding_box(self):
        return (self.ymax - self.ymin) * (self.xmax - self.xmin)

    def overlapping_bounding_boxes(self, other):
        return self.ymax > other.ymin and other.ymax > self.ymin and self.xmax > other.xmin and other.xmax > self.xmin

    def check_unique_vertices(self):
        """Check for unique vertices."""
        ok = len(self.vertices) == len(set(self.vertices))
        if not ok:
            print("NOT OK", len(self.vertices), len(set(self.vertices)))
            for edge in sorted(self.edges, key=lambda p: p.start.x):
                print(edge)
            print()
            for v in self.vertices:
                print(v)
            raise PolygonError("Unique Vertexes Not OK")
        return ok

    @staticmethod
    def _patch_hole(my_edges, edges_all):
        """Remove a hole or connect a disjoint Polygon."""
        # Find closest pairs
        points_done = [e.start for e in my_edges]
        points_todo = [e.start for e in edges_all]

        nearest_counter = -1
        factor = 0.99
        while True:
            nearest_counter += 1
            combs = list(itertools.product(points_done, points_todo))
            combs.sort(key=lambda p1_p2: Segment(p1_p2[0], p1_p2[1]).length())
            edge_t_nearest = Segment(*combs[nearest_counter])

            p_nearest_done = edge_t_nearest.start

            # Rotate the first polygon such that the new edges
            # can be added at the end.
            e_nearests = [e for e in my_edges if e.end == p_nearest_done]
            assert len(e_nearests) == 1
            e_nearest = e_nearests[0]
            i_nearest = my_edges.index(e_nearest)
            my_edges_org = my_edges
            my_edges = my_edges_org[i_nearest + 1 :] + my_edges_org[: i_nearest + 1]
            assert len(my_edges) == len(my_edges_org)
            assert my_edges[0].start == p_nearest_done
            assert my_edges[-1].end == p_nearest_done

            # Recompute edge_last
            edge_last = my_edges[-1]

            edges_all_sorted = sorted(
                edges_all,
                key=lambda e, edge_last=edge_last: (
                    (edge_last.end.x - e.start.x) ** 2 + (edge_last.end.y - e.start.y) ** 2
                ),
            )
            edge_last_short = edge_last.extend_end(factor=factor)

            edge_new = edges_all_sorted[0]
            edge_new_short = edge_new.extend_start(factor=factor)

            edge_half = [e for e in edges_all if e.end == edge_new.start][0]
            edge_half_short = edge_half.extend_end(factor=factor)

            edge_0 = [e for e in my_edges if e.start == edge_last.end][0]
            edge_0_short = edge_0.extend_start(factor=factor)

            edge_temp1 = Segment(edge_last_short.end, edge_new_short.start)
            edge_temp2 = Segment(edge_half_short.end, edge_0_short.start)

            if not edge_temp1.intersects(edge_temp2):
                # There might be other intersections too
                for e3 in [
                    e
                    for e in my_edges + edges_all + [edge_last_short, edge_new_short, edge_half_short, edge_0_short]
                    if e not in [edge_last, edge_half, edge_new, edge_0]
                ]:
                    if (
                        len({e3.start, e3.end, edge_temp1.start, edge_temp1.end}) == 4 and e3.intersects(edge_temp1)
                    ) or (len({e3.start, e3.end, edge_temp2.start, edge_temp2.end}) == 4 and e3.intersects(edge_temp2)):
                        break
                else:
                    break

                Message(
                    "Intersection in hole patching, try again new. %i" % nearest_counter, DEBUG,
                )

            Message(
                "Intersection in hole patching, try again. %i" % nearest_counter, DEBUG,
            )

        my_edges = [edge_0_short if e == edge_0 else e for e in my_edges]

        my_edges.remove(edge_last)
        my_edges.append(edge_last_short)
        my_edges.append(edge_temp1)
        my_edges.append(edge_new_short)

        edges_all.remove(edge_half)
        edges_all.append(edge_half_short)

        edges_all.remove(edge_new)
        edges_all.append(edge_temp2)
        return my_edges, edges_all

    def _sort_edges(self):
        """Ensure the edges are head to tail."""
        # edges_all are actually more like edges_todo
        edges_all = [aa for aa in self._lazy_edges]

        nr_of_edges = len(edges_all)
        my_edge = edges_all[0]
        my_edges = [my_edge]
        edges_all.remove(my_edge)

        while len(my_edges) < nr_of_edges:
            edge_last = my_edges[-1]
            edges_new = [e for e in edges_all if e.start == edge_last.end]
            if len(edges_new) == 1:
                # Normal situation
                edge_new = edges_new[0]
                edges_all.remove(edge_new)
                my_edges.append(edge_new)
            elif len(edges_new) == 0:
                # We have a 'polygon' with either a hole or a disjoint
                # 'polygon'.
                # Create a very small connection between those.
                ss = [e.start for e in my_edges]
                ee = [e.end for e in my_edges]
                assert set(ss) == set(ee)
                Message("We have a hole", DEBUG)

                my_edges, edges_all = self._patch_hole(my_edges, edges_all)

                nr_of_edges += 2

            else:
                raise PolygonError("Cannot Happen, polygon is tree")

        self._lazy_vertices = None
        self._lazy_edges = my_edges

    def shuffle(self, r=0.1):
        assert len(self.check_self_intersection()) == 0, "Already self intersections in shuffle"

        def do_shuffle(poly):
            points_new = [Point(p.x + random.random() * r, p.y + random.random() * r,) for p in poly.vertices]
            polyn = Polygon()
            polyn._lazy_vertices = points_new
            return polyn

        polynew = do_shuffle(self)
        while len(polynew.check_self_intersection()) > 0:
            r = r / 2
            Message("Problem shuffling, halving r to %s." % r, DEBUG)
            polynew = do_shuffle(self)
        return polynew

    def orientation(self):
        """
        http://stackoverflow.com/questions/1165647/how-to-determine-if-a-list-of-polygon-points-are-in-clockwise-order
        """
        return sum((edge.end.x - edge.start.x) * (edge.end.y + edge.start.y) for edge in self.edges)

    def reorient(self):
        if self.orientation() < 0:
            self._lazy_vertices = None
            self._lazy_edges = [Segment(start=edge.end, end=edge.start) for edge in self._lazy_edges]

    def union(self, other):
        try:
            # All inside one another?
            if all(p.inside(other) for p in self.vertices):
                Message("Self inside other", DEBUG)
                return other
            if all(p.inside(self) for p in other.vertices):
                Message("Other inside self", DEBUG)
                return self

            edges_combined = self.find_union_edges(other)
            Message(
                "Going to construct poly_combined %s %s" % (len(edges_combined), len(set(edges_combined))), DEBUG,
            )
            return Polygon(edges=edges_combined)
        except Exception:
            # Sometimes the order matters for holes patching.
            Message("Trying union the other way around.", DEBUG)
            return other.union(self)

    def check_self_intersection(self):
        intersections = []
        for edge1 in self.edges:
            for edge2 in self.edges:
                if len({edge1.start, edge1.end, edge2.start, edge2.end}) == 4 and edge1.intersects(edge2):
                    intersections.append((edge1, edge2, edge1.intersection(edge2)))

        return intersections

    def find_intersections(self, edge):
        """Find intersections between with edge."""
        intersections = []
        for edge2 in self.edges:
            if edge.intersects(edge2):
                intersection = edge.intersection(edge2)
                if intersection not in intersections:
                    intersections.append(intersection)
        return intersections

    @staticmethod
    def _find_edges_combined(p_a, p_b):
        """Combine edges of two polygons."""
        edges_combined = []
        for p1, p2, name in [(p_a, p_b, "pAfirst"), (p_b, p_a, "pBfirst")]:
            for edge1 in p1.edges:
                intersections = p2.find_intersections(edge1)
                if not intersections:
                    # Add the edge if it is not fully in the overlapping region.
                    if not (edge1.start.inside(p2) and edge1.end.inside(p2)):
                        edges_combined.append(edge1)
                elif len(intersections) == 1:
                    intersection = intersections[0]
                    # Add correct half.
                    ss = (
                        Segment(intersection, edge1.end)
                        if edge1.start.inside(p2)
                        else Segment(edge1.start, intersection)
                    )
                    edges_combined.append(ss)
                else:
                    Message("Too many intersections, halving", DEBUG)
                    return False, [p1, edge1, intersections]

        return True, edges_combined

    def find_union_edges(self, other):
        """Find the edges that form the union between self and other.

        First loops over all edges of 'self', then over all edges of
        'other' and adds those parts that are outside the other
        polygon. Both polygons have to be oriented in the same way.
        """

        p_a = self
        p_b = other
        success, edges_combined = False, []
        while not success:
            success, edges_combined = self._find_edges_combined(p_a, p_b)
            if success:
                Message("Success", DEBUG)
            else:
                pp, edge, intersections = edges_combined
                intersections.sort(key=lambda p, edge=edge: p.x if (edge.start.x < edge.end.x) else -p.x)
                xm = (intersections[0].x + intersections[1].x) / 2
                ym = (intersections[0].y + intersections[1].y) / 2
                pm = Point(xm, ym)
                edges_new = [e for e in pp.edges if e != edge] + [
                    Segment(edge.start, pm),
                    Segment(pm, edge.end),
                ]

                ppnew = Polygon(edges=edges_new)
                ppnewok = ppnew.check_unique_vertices()
                if not ppnewok:
                    print("=== ppnew NOT ok?  %s" % ppnew.check_unique_vertices())
                if pp == p_a:
                    p_a = ppnew
                elif pp == p_b:
                    p_b = ppnew
                else:
                    raise PolygonError("Cannot Happen, Failed Halving")

        return edges_combined

    def __init__(self, vertices=None, edges=None):
        if vertices is not None and edges is not None:
            print("Give edges OR vertices.")
        elif vertices is not None:
            self._lazy_vertices = vertices
            self._lazy_edges = None
        elif edges is not None:
            self._lazy_vertices = None
            self._lazy_edges = edges
            self._sort_edges()

        if self._lazy_vertices or self._lazy_edges:
            inters = self.check_self_intersection()
            assert len(inters) == 0, "Self intersections: %s" % (len(inters))

    def __eq__(self, other):
        # TODO: Sort vertices?
        if len(self) != len(other):
            return False
        else:
            return all(p1 == p2 for (p1, p2) in zip(self.vertices, other.vertices))

    def __len__(self):
        return len(self.vertices)
